import pdb
import numpy as np
import igraph as ig
import sys
import copy
import itertools as it
import pandas as pd
import matplotlib.pyplot as plt

# Tree cluster class
#
# Constructor parameters
#   @param g a igraph.Graph object.  The graph must be directed tree.
#   @param m_list a list of numpy matrices.  The matrices must all
#   have the same number of columns, but can differ in the number of
#   rows.  The number of columns must equal to number of vertices in g
#   and column i is taken to correspond to vertex i.
#   @param K the number of components
#
#
# A tree cluster object partitions a tree into  
# disjoint, connected components.  The partition
# is specified by K-1 vertices called cut vertices.  
# The components of the tree are generated by cutting some
# of the edges going OUT of each cut vertex, and these edges
# are referred to as cut edges.  In practice, the tree_cluster
# object only stores the cut edges since those provide the cut
# vertices.
#
# Fitting is done by coordinate descent.  A cut vertex is chosen 
# and is iteratively replaced by all other vertices in the tree to
# see if there is a better choice.  Similarly, 
# for each cut vertex, all possible cut edge combinations associated
# with that cut vertex are considered.
class tree_cluster:
    
    def __init__(self, g, m_list, K):
        self.K = K
        self.m = m_list
        self.g = g
        
        # check consistency of g and m_list
        ncols = list(set([m.shape[1] for m in m_list]))
        if not len(ncols) == 1:
            sys.exit("matrices in m_list must have same number of columns")
        if not ncols[0] == g.vcount():
            sys.exit("number of vertices does not match number of columns")
        
        self.info = self.form_tree_information(g)
       
        # checks on K
        if K < 2 or K > len(self.info["internal"]):
            sys.exit("K out of range")
        
        # a list of edge lists.  cutting these edges forms the components
        self.cut_edges = None
        # assignment of each vertex in g to a component
        self.assignments = None
        # mediod of each component
        self.mediods = None
        
        
    @staticmethod
    def form_tree_information(g):
        # find the root
        nv = g.vcount()
        
        is_root = np.array([len(g.neighbors(i, mode=ig.IN))==0 for i in range(nv)])
        if (not np.sum(is_root) == 1):
            pdb.set_trace()
            sys.exit("there is not one root")
        root = np.where(is_root)[0][0]
        
        children = [g.neighbors(v, mode=ig.OUT) for v in range(nv)]
        leaves = [v for v in range(nv) if len(children[v]) == 0]
        
        # internal vertices are possible cut vertices
        internal_vertices = list(range(nv))
        for v in leaves:
            internal_vertices.remove(v)
            
        info = {'root':root,
                'leaves':leaves,
                'internal':internal_vertices,
                'children':children}
        
        return info
 
        
    # pick random cut vertices and include all outgoing edges
    # as the cut edges
    def initialize_components(self,initial_cutedges = [], assignments = []):
        g = self.g
        if len(assignments)>0:
            if not self.K == len(set(assignments)):
                pdb.set_trace()
                sys.exit("number of components does not equal number of clusters")
          
            self.assignments = assignments
            self.update_mediods()            
            
            cut_edges = []
            for cluster in range(1,self.K):
                in_cluster = [vertex for vertex, a in enumerate(assignments) if a==cluster]
                cut_edges_cluster = [(u,v) for v in in_cluster for u in self.g.predecessors(v) if u not in in_cluster]
                cut_edges.append(cut_edges_cluster)
            self.cut_edges = cut_edges
        else:
            if(len(initial_cutedges)>0):
                cut_edges = initial_cutedges
            else:    
                cut_vertices = np.random.choice(self.info['internal'], 
                                                    self.K-1, 
                                                    replace=False)
                # all children will form cut edges
                cut_edges = [[(v, u) for u in g.neighbors(v, mode=ig.OUT)] for v in cut_vertices]     
            self.cut_edges = cut_edges
            self.update_components()
    # cut vertices are the parent vertices of the cut edges
    def get_cut_vertices(self):
        v = [e[0][0] for e in self.cut_edges]
        return v
    
    def get_assignments(self):
        return self.assignments
    
    def get_mediods(self):
        return self.mediods
           
    def update_components(self):
        g_comp = self.g.copy()
        for e in self.cut_edges:
            # add a linker node
            g_comp.add_vertex(1)
            link_vertex = g_comp.vcount() - 1
            link_edges = [(link_vertex, ce[1]) for ce in e]
            g_comp.add_edges(link_edges)
            g_comp.delete_edges(e)
        # get components
        all_assignments = np.array(g_comp.components(mode=ig.WEAK).membership)
        assignments = all_assignments[range(self.g.vcount())]
        
        # check for situation that should never occur
        if not self.K == len(set(assignments)):
            pdb.set_trace()
            sys.exit("number of components does not equal number of clusters")
      
        self.assignments = assignments
        self.update_mediods()
                
            
    def update_mediods(self):
        K = self.K
        m = self.m
        r = range(len(m))
        a = self.assignments
        
        cluster_means = [[np.mean(m[i][:,a==k]) for k in range(K)] for i in r]
        self.mediods = np.array(cluster_means)
        
    def compute_residual2(self):
        K = self.K
        mediods = self.mediods 
        a = self.assignments
        m = self.m
        
        lm = len(m)
        col_ind = [np.where(a == k)[0] for k in range(self.K)]
        ss2 = 0
        
        for j in range(lm):
          for k in range(K):
            res2 = (m[j][:,col_ind[k]] - mediods[j,k])**2
            ss2 = ss2 + np.sum(res2)
            
        return ss2
   
    
    # for a given cut vertex, all outgoing edges can be cut edges.
    # execute a step of a stochastic ascent over the
    # possible combinations of the cut edges
    def optimize_cut_edges(self, index, noise=0):
        
        cut_vertex = self.get_cut_vertices()[index]
        children = self.info['children'][cut_vertex]
        nc = len(children)
        if nc == 1:
            return None
        e = [(cut_vertex, child) for child in children]
        
        # all possible combinations of children, with at least one
        # child
        configs_it = it.product([False, True],repeat=nc)
        configs = np.array([x for x in configs_it])
        configs = configs[np.sum(configs, 1) != 0,:]
        
        loss = np.repeat(-1, configs.shape[0])
        for r in range(configs.shape[0]):
            current_edges = [e[i] for i in range(nc) if configs[r,i]]
            self.cut_edges[index] = current_edges
            self.update_components()
            loss[r] = self.compute_residual2()
            
        best_row = np.argmin(loss)
        final_edges = [e[i] for i in range(nc) if configs[best_row,i]]
        self.cut_edges[index] = final_edges
        self.update_components()
        
        
      
            
    # coordinate descent on a single cut vertex
    def optimize_cut_vertex(self, i, noise=0):
    
        current_loss = self.compute_residual2()
        
        cut_vertices = self.get_cut_vertices()
        children = self.info['children']
        
        alternate_vertices = copy.deepcopy(self.info['internal'])
        for v in cut_vertices:
            alternate_vertices.remove(v)
          
        save_edge_cuts = copy.deepcopy(self.cut_edges[i])
        new_loss = np.repeat(-1.0, len(alternate_vertices))
        for j in range(len(alternate_vertices)):
            ca = alternate_vertices[j]
            self.cut_edges[i] = [(ca,v) for v in children[ca]]
            self.update_components()
            new_loss[j] = self.compute_residual2()
            
        if (min(new_loss) < current_loss) or (np.random.uniform() < noise):
            a = alternate_vertices[np.argmin(new_loss)]
            self.cut_edges[i] = [(a,v) for v in children[a]]
        else:
            self.cut_edges[i] = save_edge_cuts
            
        self.update_components()

    # single starting point optimizatino
    def optimize(self):
        if self.cut_edges is None:
            sys.exit("cut edges must be initialized before fitting")
        previous_loss = self.compute_residual2()
        iteration = 1
        while True:
           print(["iteration", iteration, previous_loss])
           indices = np.random.permutation(self.K-1)
           for index in indices:
                self.optimize_cut_vertex(index)
                self.optimize_cut_edges(index)
                print(["index", index, self.compute_residual2()])
                
           current_loss = self.compute_residual2()
           if current_loss > previous_loss:
                pdb.set_trace()
                sys.exit("unexpected state!")
           elif current_loss < previous_loss:
                previous_loss = current_loss
                iteration = iteration + 1
           else:
                break
            
    # find best of many optimizations 
    def fit(self, num_runs=10):
        cut_edges = []
        loss = np.repeat(-1, num_runs)
        for i in range(num_runs):
            print(["run", i])
            self.initialize_components()
            self.optimize()
            cut_edges.append(self.cut_edges)
            loss[i] = self.compute_residual2()
            
        best_cut_edges = cut_edges[np.argmin(loss)]
        self.cut_edges = best_cut_edges
        
        return best_cut_edges
    
    def treeplot(self,savepath='',vertex_label=False, m_index=None):
        a = self.assignments
        g = self.g
        vs = {}
        
        if a is not None:
            pal = ig.drawing.colors.ClusterColoringPalette(self.K)
            vs["vertex_color"] = pal.get_many(a)
                  
        vs["bbox"] = (1200, 1000)
        if m_index is None:
            vs["vertex_size"] = 20
        else:
            vs["vertex_size"] = 30*np.mean(self.m[m_index], 0) + 1
        vs["vertex_label_size"] = 20
        if vertex_label:
            vs["vertex_label"] = g.vs['name']
        else:
            vs["vertex_label"] = [str(i)  for i in range(g.vcount())]
        vs["vertex_label_dist"] = 1.5
           
        layout = g.layout_reingold_tilford()
     
        if savepath == '':
            pl = ig.plot(g, layout=layout, **vs)
            pl.show()
        else:
            ig.plot(g,savepath,layout=layout, **vs)
        
    def boxplot(self, num_m_index=6):
        a = self.assignments
        m = self.m
        
        tb = pd.DataFrame({'cluster':a})
        for i in range(num_m_index):
          p = np.mean(m[i], axis=0)
          tb.insert(tb.shape[1], "row_" + str(i), p)
                  
        tb.boxplot(by="cluster")
        
        return tb
    
    def heatmap(self, num_m_index=None):
        if num_m_index is None:
            num_m_index = len(self.m)
            
        K = self.K
        lm = len(self.m)
        a = self.assignments
        
        hm = np.ndarray([lm, K])
        
        for i in range(lm):
            for k in range(K):
                m = self.m[i][:,a==k]
                hm[i,k] = np.median(np.mean(m, axis=0))
                
        #fig, ax = plt.subplots()
        plt.imshow(hm, interpolation='nearest')

        # We want to show all ticks...
        #plt.set_xticks(np.arange(K))
        #plt.set_yticks(np.arange(lm))
        # ... and label them with the respective list entries
        #plt.set_xticklabels([str(i) for i in range(K)])
        #plt.set_yticklabels(str(i) for i in range(lm))

        # Loop over data dimensions and create text annotations.
        for i in range(lm):
            for k in range(K):
                text = plt.text(k, i, np.round(10*hm[i, k])/10,
                       ha="center", va="center", color="w",
                       size="x-small")

        #plt.set_title("Clusters")
        #fig.tight_layout()
        plt.show()